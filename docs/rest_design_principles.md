# REST 设计原则

我交谈过的大多数开发人员最终都会谈论 REST，他们都希望构建尽可能最好的 REST API。这当然会引发关于什么是好的 REST API 的常见讨论，或者您应该如何确保您的 API 是 REST风格的。有时，气氛会很紧张，所以我决定写一篇文章来解决这个问题。

这篇文章旨在收集我所认为的 REST 背后的主要设计原则。我当然会更新该文档，以反映我的任何不足或任何可以帮助任何有疑问的人的新想法。

## 什么是REST

REST 或“表述性状态传输”是一种架构风格，它定义了 Web 服务的设计和行为方式。REST 定义了一组必须遵循的约束，以便在互联网上的系统之间提供更好的互操作性。遵循这些原则的 Web 服务被认为是 REST风格的。

“表征性状态转移”一词由[Roy Fielding](https://en.wikipedia.org/wiki/Roy_Fielding)于 2000 年在其[博士论文](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)第 5 章中引入。

REST 背后的基本支柱之一是客户端-服务器架构风格约束的形式化。客户端和服务器遵循“用户界面关注点和数据存储关注点”之间的关注点分离，这允许客户端和服务器系统彼此独立地发展。

我将尝试总结每个约束，然后展示它如何应用于 HTTP 以及我们如何应用它来开发 Web 服务。

## 客户端服务器

客户端-服务器约束基于一侧的用户界面关注点和另一侧的数据存储关注点之间的关注点分离。这种分离使我们能够提高用户界面跨多个平台的可移植性，并由于其简化而提高服务器组件的可扩展性。

此外，这种分离允许不同的关注点彼此独立地发展，这对于支持多个组织域的互联网规模要求至关重要。

## 无国籍

无状态约束假设客户端和服务器之间的通信是无状态的，并且来自客户端的每个请求必须包含服务器执行请求的操作所需的所有信息。服务器上的每个操作必须完全独立于之前可能发生的任何其他请求。

在请求之间不需要将客户端上下文存储在服务器上，因此客户端单独负责存储和处理所有应用程序状态。

通过从服务器中删除客户端状态，我们能够简化服务器逻辑并更好地扩展。此外，服务器上的请求可以并行发生，而不必担心交互语义。

## 缓存

缓存约束是一种通过显式或隐式地将响应数据标记为可缓存或不可缓存来提高网络效率的方法。如果响应被标记为可缓存，则允许客户端将响应数据重用于等效请求。

通过添加缓存，我们的目标是部分或完全消除客户端和服务器之间的交互。交互次数的减少和延迟的减少将大大提高用户感知的性能以及不同关注点的效率和可扩展性。

这样做的一个缺点是缓存数据的可靠性降低，因为它可能与服务器存储的数据有很大不同。第二个缺点是数据更改时使缓存失效会增加复杂性。

## 统一接口

统一接口约束是 REST 系统的基本支柱。这些约束旨在简化和解耦架构，并允许每个部分独立发展。这个约束包含4个原则：

### 1. 资源识别

REST 中的关键抽象是资源。资源是任何可以命名（使用名词）并映射一组实体的东西。每个资源都是唯一且独立的，因此可以使用资源标识符来识别和引用。数据存储中资源的表示在概念上与返回给客户端的表示是分开的。

### 2. 通过表征操纵资源

表示由描述资源的数据和元数据组成，并且出于消息完整性的目的，表示还可以包含元数据来描述元数据。

表示允许客户端保存足够的信息来显示、修改或删除资源。

### 3. 自我描述消息

每条消息都包含有关如何处理该消息的足够信息。接收响应的客户端完全能够解析消息并将任何业务逻辑应用于消息的内容。

### 4. 超媒体作为应用程序状态的引擎

通过使用初始 URI，客户端应该能够使用服务器提供的链接来动态发现所有可用的操作和资源。当客户端处理返回的响应时，客户端可用的动作和资源可以动态地改变，并且客户端应该不需要关于返回资源的结构、动作和动态的硬编码信息。

## 分层系统

分层系统允许在客户端和服务器之间的通信的各个点引入代理、网关和防火墙，而无需更改不同组件之间的接口。这种分层架构可以提高性能和可扩展性。REST 的无状态约束和自描述消息支持添加中间处理。

## 按需编码

客户端从服务器接收代码的能力，使客户端能够在不知道数据语义的情况下正确处理数据。

## REST 和 HTTP

了解了 REST 假定的六个约束后，我们现在可以看看它们在处理 HTTP 时是如何应用的。因此，让我们开始查看资源并从那里继续。

## 资源

如前所述，REST 中的一切都是资源。因此，当开始编写新的 API 时，应该首先确定 API 将处理的资源。任何可以命名的东西都是资源的良好候选者。请记住，资源应该是名词而不是动词。这是一个例子：

> Article  
> User  
> Author  
> Image  
> Bird

## 统一URI

大多数开发人员都会犯这样的错误：设计路由来使用动词来操作资源，这是[RPC](https://en.wikipedia.org/wiki/Remote_procedure_call)的典型特征。设计 REST 服务时，应该关注名词。例如，如果其中一个资源是“文章”，那么要获取所有文章，您应该有一个如下所示的路线

> /articles

并不是

>/getAllArticles

下面提到的 HTTP 方法将有助于区分您在“文章”资源上执行的操作。此外，惯例是使用复数形式“文章”。一旦我们了解了 HTTP 方法，这就会更有意义。

当引用整个“Arritcles”集合时，URI 将如下所示

>/articles

当要引用文章集合中的特定文章时，您将有一条如下所示的URL路径：

>/articles/123456789

因此，在谈论统一 URI 时，应该意识到 API 中资源的 URI 变得统一，因为它们遵循相同的语义。如果我们进一步了解文章资源并添加“作者”，我们可以看到 API 中生成的路由遵循相同的模式。

>/articles  
>/articles/123456
>
>/authors  
>/authors/123456

这使客户端程序员干起活来变得更容易，因为他们不需要浏览大量文档来了解如何使用 API，他们需要知道的是公开了哪些资源。

## 过滤、排序、分页……

在查看 RESTful 服务中的统一 URI 时，发送请求时您可能会想做的一件事是添加某些控制信息，例如在 HTTP 请求标头中添加过滤、排序和/或分页，或者更糟糕的是作为请求负载的一部分。不幸的是，这不是最好的方法。

最正确的方法（也能很好地适应超媒体约束）是将此控制信息作为路由的一部分包含在查询字符串中。就像这样：

>/articles?author=chris

虽然这很好，但不太灵活。上面的过滤器仅适用于精确匹配。问题是 URL 参数只有一个键和一个值，但过滤器可以由三个组件组成：

- 字段名称
- 运营商
- 过滤值

### 左方括号

解决该问题的一种方法是使用以这种方式组成的 LHS 括号

```ini
author[eq]=chris
status[ne]=past
count[gte]=200
```

使用 LHS 括号，我们可以拥有所需数量的运算符`[lte]`、`[gte]`、`[eq]`等。结果看起来像这样。

> /articles?author[eq]=chris

LHS 括号在服务器上的实现可能稍微复杂一些，但提供了更大的灵活性。

## HTTP 方法

在创建 REST API 时，我们已经提到您需要使用名词而不是动词。那么我们如何表达路线的意图呢？我们如何表达要对资源执行的操作？这就是 HTTP 方法发挥作用的地方。重要的是要用正确的方法，采取正确的行动。

### GET

GET方法仅用于检索资源，而不是[修改](https://tools.ietf.org/html/rfc7231#section-4.3.1)或创建资源。GET 端点被称为安全端点，因为它们不会更改资源的状态。此外，GET 端点必须是[幂等](https://en.wikipedia.org/wiki/Idempotence)的。这意味着发出多个相同的请求每次都必须产生相同的结果，直到在服务器上对资源进行更改为止。

GET 请求不应包含正文，但应在查询字符串中发送请求所需的任何参数。过滤器或寻呼参数就是一个例子。

如果在 API 中找到该资源，则端点必须返回 HTTP 响应代码 200（正常）以及包含客户端要求格式的资源的正文。

如果在 API 中未找到资源，则端点必须返回 HTTP 响应代码 404（未找到）。

如果 API 确定 GET 请求格式不正确，则它必须返回 HTTP 响应代码 400（错误请求）。

### POST

POST[方法](https://tools.ietf.org/html/rfc7231#section-4.3.3)仅用于创建新资源。POST 端点不被认为是安全的，因为它们会导致 API 中的资源集合发生变化。POST 不是幂等的，因为调用两个相同的 POST 端点将导致创建两个包含相同数据但不同 id 的不同资源。

如果资源已在 API 中创建，则端点必须返回 HTTP 响应代码 201 (CREATED)，并在响应消息中包含新创建的资源，并具有 Location 标头。

如果 POST 端点在创建可通过 URI 标识的资源之前返回响应，则端点必须返回 HTTP 响应代码 200（正常）或 202（已接受）。

对 POST 的响应不可缓存，除非它们包含适当的 Cache-Control 或 Expires 标头字段。

如果 API 确定 POST 格式不正确，则它必须返回 HTTP 响应代码 400（错误请求）。

### PUT

PUT方法主要用于替换现有资源，或者如果资源不存在，API 可能会选择创建新资源。PUT 端点不被认为是安全的，但它们被认为是幂等的。

如果在 API 中找到资源并成功修改，则端点必须返回 HTTP 响应代码 200（正常）或 204（无内容）。

如果在 API 中未找到资源，则端点必须返回 HTTP 响应代码 404（未找到）。

如果在 API 中未找到该资源，但该资源是由 PUT 端点创建的，则该端点必须返回 HTTP 响应代码 201 (CREATED)，并在响应消息中包含新创建的资源。

POST 和 PUT 之间的区别在于 URI 的目标。POST URI 的目标是资源集合，而 PUT URI 的目标是单个资源。当然，POST 端点并不意味着修改现有资源。

### PATCH

PATCH方法主要用于部分更新现有资源，或者如果资源不存在，API 可以选择或不创建新资源。PATCH 端点不被认为是安全的或幂等的。

如果在 API 中找到资源并成功修改，则端点必须返回 HTTP 响应代码 200（正常）或 204（无内容）。

如果在 API 中找到资源但由于状态冲突而无法修改，则端点必须返回 HTTP 响应代码 409（冲突）。

如果在 API 中未找到资源，则端点必须返回 HTTP 响应代码 404（未找到）。

### Delete

DELETE方法用于删除由 URI 标识的现有资源。DELETE 端点是幂等的，因为在同一资源上调用删除会产生相同的结果。

如果在 API 中找到资源并成功删除，则端点必须返回 HTTP 响应代码 200（正常）（如果响应包含描述状态的实体），或者 202（已接受）（如果操作已排队）或 204（否） CONTENT）如果操作已执行但响应不包含实体。

如果在 API 中未找到资源，则端点必须返回 HTTP 响应代码 404（未找到）。

### 不同的表现形式

资源可以有多种表示形式，不同的客户端也可能希望根据自己的需要以不同的方式表示资源。因此，客户端可以发送对以特定形式表示的资源的请求，这就是所谓的内容协商。

内容协商可以使用标头完成

```json
Content-Type: application/json
```

或通过 URL 模式

> https://api.domain.com/v1/articles/123456.xml
> https://api.domain.com/v1/articles/123456.json

## 参考

- [基于网络的软件架构的架构风格和设计](https://www.ics.uci.edu/~fielding/pubs/dissertation/fielding_dissertation.pdf)

以下文档共同定义了 HTTP/1.1 协议：

- [RFC 7230](https://tools.ietf.org/html/rfc7230)：消息语法和路由
- [RFC 7231](https://tools.ietf.org/html/rfc7231)：语义和内容
- [RFC 7232](https://tools.ietf.org/html/rfc7232)：条件请求
- [RFC 7233](https://tools.ietf.org/html/rfc7233)：范围请求
- [RFC 7234](https://tools.ietf.org/html/rfc7234)：缓存
- [RFC 7235](https://tools.ietf.org/html/rfc7235)：身份验证
- [RFC 5789](https://tools.ietf.org/html/rfc5789)：HTTP 的 PATCH 方法

## 原文链接

- [REST Design principles](https://christiangiacomi.com/posts/rest-design-principles/)
